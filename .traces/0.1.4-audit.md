# Security Audit Report: emblem-vault-ai-signers v0.1.4

**Date:** 2025-11-10
**Auditor:** Claude Code Security Review
**Scope:** Complete codebase security analysis

---

## Executive Summary

This document contains a comprehensive security audit of the emblem-vault-ai-signers package version 0.1.4. The audit covers all source code files, examining potential vulnerabilities including but not limited to:

- Injection attacks (XSS, command injection, SQL injection)
- Authentication and authorization issues
- Cryptographic weaknesses
- Input validation and sanitization
- Error handling and information disclosure
- Dependency security
- API security

**Overall Assessment:** The codebase demonstrates good security practices with TypeScript type safety and proper separation of concerns. The library is designed for both server-side and client-side use, where users provide their own API keys. Several issues were identified related to race conditions, input validation, and error handling that should be addressed.

**Overall Security Score: 7.5/10**

### Critical Statistics

- **Total Issues Found:** 25
- **Critical Severity:** 0
- **High Severity:** 1
- **Medium Severity:** 5
- **Low Severity:** 17
- **Informational:** 2

---

## Audit Progress

**Status:** ✅ Complete

### Files Audited
- [x] src/http.ts
- [x] src/vault.ts
- [x] src/types.ts
- [x] src/utils.ts
- [ ] src/index.ts
- [ ] src/viem.ts
- [ ] src/ethers.ts
- [ ] src/web3.ts
- [ ] src/solana.ts

---

## Findings

### 1. HTTP Module (src/http.ts)

**Lines Reviewed:** 1-45

#### Vulnerabilities Identified:

##### LOW SEVERITY - Missing URL Validation
**Location:** `http.ts:8` and `http.ts:31`
**Issue:** The `baseUrl` and `path` parameters are concatenated without basic validation.

```typescript
const res = await fetch(`${baseUrl}${path}`, {
```

**Note on Security Context:**
This library is designed for both server-side and client-side use where users provide their own API keys. In client-side contexts, any code has full access to API keys and can modify requests regardless of validation. Therefore, URL validation is primarily for error handling rather than security.

**Risk:**
- Developer mistakes could cause confusing runtime errors
- Malformed URLs could lead to unclear error messages
- No protection against typos in configuration

**Recommendation:**
Add basic input validation for better error messages:

```typescript
function validateUrlInputs(baseUrl: string, path: string): void {
  if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {
    throw new Error('baseUrl must be a valid HTTP(S) URL');
  }
  if (!path.startsWith('/')) {
    throw new Error('path must start with /');
  }
}
```

**Priority:** LOW - Error handling improvement, not a security vulnerability

##### MEDIUM SEVERITY - Information Disclosure
**Location:** `http.ts:21` and `http.ts:40`
**Issue:** Error messages include server response text which may contain sensitive information.

```typescript
throw new Error(`Emblem signer error ${res.status}: ${text || res.statusText}`);
```

**Risk:**
- Server errors might expose internal implementation details
- Stack traces or debug info could be leaked to client
- API keys or tokens might appear in error responses

**Recommendation:**
- Sanitize error messages before throwing
- Log full error details server-side only
- Return generic error messages to clients

##### LOW SEVERITY - API Key Exposure in Headers
**Location:** `http.ts:12` and `http.ts:34`
**Issue:** API key is passed in custom header `x-api-key`.

**Current Implementation:**
```typescript
headers: {
  "x-api-key": apiKey,
}
```

**Considerations:**
- Custom headers are visible in browser dev tools and network logs
- Better than query params, but less secure than Authorization Bearer tokens
- No validation that apiKey is non-empty or properly formatted

**Recommendation:**
- Validate apiKey is non-empty before making request
- Consider using standard `Authorization: Bearer ${apiKey}` header
- Document that apiKey should never be used in client-side browser code

##### LOW SEVERITY - Missing Request Timeout
**Location:** `http.ts:8` and `http.ts:31`
**Issue:** No timeout configured for fetch requests.

**Risk:**
- Requests could hang indefinitely
- Denial of service if server doesn't respond
- Poor user experience

**Recommendation:**
```typescript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 30000);
const res = await fetch(url, {
  ...options,
  signal: controller.signal
});
clearTimeout(timeoutId);
```

##### POSITIVE FINDINGS:

1. ✅ **Bigint Serialization**: Proper handling of bigint values prevents JSON serialization errors
2. ✅ **HTTPS Default**: Default baseUrl uses HTTPS protocol
3. ✅ **Content-Type Header**: Correctly set to application/json
4. ✅ **Error Handling**: Try-catch on response.text() prevents crashes
5. ✅ **Type Safety**: Uses TypeScript generics for type safety

#### Security Score: 7/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 1 (Information disclosure)
**Low Issues:** 3 (URL validation, API key exposure, missing timeout)

---

### 2. Vault Module (src/vault.ts)

**Lines Reviewed:** 1-27

#### Vulnerabilities Identified:

##### MEDIUM SEVERITY - Unsafe Error Handling and Fallback
**Location:** `vault.ts:12-17`
**Issue:** Catches all errors from GET request and silently falls back to POST, potentially masking real errors.

```typescript
try {
  data = await emblemGet("/vault/info", config);
} catch (err: any) {
  // Some environments may require POST for this endpoint; try POST fallback
  data = await emblemPost("/vault/info", {}, config);
}
```

**Risk:**
- Real authentication/authorization errors are hidden
- Network errors are masked
- Invalid API keys won't be reported clearly
- Second POST request might succeed where it shouldn't, bypassing security checks

**Recommendation:**
- Only fallback for specific error codes (e.g., 405 Method Not Allowed)
- Log the original error before retrying
- Consider making fallback behavior configurable

**Proposed Fix:**
```typescript
try {
  data = await emblemGet("/vault/info", config);
} catch (err: any) {
  if (err.message?.includes('405') || err.message?.includes('Method Not Allowed')) {
    data = await emblemPost("/vault/info", {}, config);
  } else {
    throw err;
  }
}
```

##### LOW SEVERITY - Missing Response Validation
**Location:** `vault.ts:19-25`
**Issue:** No validation that required fields exist or are properly formatted.

**Risk:**
- Undefined values could propagate through the application
- Invalid addresses could cause downstream errors
- Type coercion assumes server returns correct format

**Recommendation:**
```typescript
if (!data.vaultId || !data.address || !data.evmAddress) {
  throw new Error('Invalid vault info response: missing required fields');
}
if (!data.evmAddress.startsWith('0x')) {
  throw new Error('Invalid evmAddress format');
}
```

##### POSITIVE FINDINGS:

1. ✅ **Data Normalization**: Creates consistent return structure with tokenId alias
2. ✅ **Optional Fields**: Properly handles optional `created_by` field
3. ✅ **Type Safety**: Uses TypeScript types for return value

#### Security Score: 7/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 1 (Unsafe error handling)
**Low Issues:** 1 (Missing validation)

---

### 3. Type Definitions (src/types.ts)

**Lines Reviewed:** 1-18

#### Vulnerabilities Identified:

##### LOW SEVERITY - Weak Type Constraints
**Location:** `types.ts:1`
**Issue:** `Hex` type allows any string starting with "0x", including invalid hex.

```typescript
export type Hex = `0x${string}`;
```

**Risk:**
- `0x` is technically valid but represents empty/zero
- `0xZZZ` would pass type checking but is invalid hex
- Runtime validation still required

**Note:** This is a TypeScript limitation and would require runtime validation.

##### INFORMATIONAL - apiKey Type Too Permissive
**Location:** `types.ts:6`
**Issue:** `apiKey: string` accepts empty strings or whitespace.

**Recommendation:**
- Add JSDoc warning that apiKey must be non-empty
- Consider a branded type for stronger guarantees

#### Security Score: 8/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 0
**Low Issues:** 1 (Weak type constraints)

---

### 4. Utilities Module (src/utils.ts)

**Lines Reviewed:** 1-53

#### Vulnerabilities Identified:

##### MEDIUM SEVERITY - Integer Overflow Risk
**Location:** `utils.ts:23-24`
**Issue:** Converting bigint to Number without bounds checking.

```typescript
if (out.nonce !== undefined) out.nonce = Number(out.nonce);
if (out.chainId !== undefined) out.chainId = Number(out.chainId);
```

**Risk:**
- BigInts larger than Number.MAX_SAFE_INTEGER will lose precision
- Could result in incorrect nonce values
- ChainId overflow is less likely but theoretically possible

**Recommendation:**
```typescript
if (out.nonce !== undefined) {
  const n = Number(out.nonce);
  if (!Number.isSafeInteger(n)) {
    throw new Error('Nonce value too large for safe integer conversion');
  }
  out.nonce = n;
}
```

##### LOW SEVERITY - Mutation of Input Object
**Location:** `utils.ts:11-39`
**Issue:** `normalizeTxForEmblem` mutates properties and deletes fields from spread object.

```typescript
const out: any = { ...tx };
// ... modifies out
delete out.type;
delete out.accessList;
```

**Risk:**
- While spreading prevents direct mutation, the pattern is error-prone
- Future maintainers might remove the spread
- Deleted fields might be important in some contexts

**Recommendation:**
- Document that this function removes certain fields
- Consider preserving original object in a property for debugging

##### LOW SEVERITY - Missing Input Validation in bytesToHex
**Location:** `utils.ts:46-52`
**Issue:** No validation that array values are valid bytes (0-255).

```typescript
export function bytesToHex(bytes: ArrayLike<number>): Hex {
  let out = "0x";
  for (let i = 0; i < bytes.length; i++) {
    out += (bytes[i] as number).toString(16).padStart(2, "0");
  }
  return out as Hex;
}
```

**Risk:**
- Negative numbers would produce invalid hex
- Numbers > 255 would produce multi-character hex codes
- Non-integer values would produce unexpected results

**Recommendation:**
```typescript
if (bytes[i] < 0 || bytes[i] > 255 || !Number.isInteger(bytes[i])) {
  throw new Error(`Invalid byte value at index ${i}: ${bytes[i]}`);
}
```

##### POSITIVE FINDINGS:

1. ✅ **Hex Validation Regex**: `isHexString` uses proper regex pattern
2. ✅ **Consistent Conversion**: `toHexIfBigInt` properly handles bigint to hex
3. ✅ **EIP-1559 Compatibility**: Proper fallback from EIP-1559 to legacy gas pricing
4. ✅ **Gas Field Normalization**: Correctly maps `gas` to `gasLimit`

#### Security Score: 7/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 1 (Integer overflow)
**Low Issues:** 2 (Object mutation, missing validation)

---

### 5. Client Entry Point (src/index.ts)

**Lines Reviewed:** 1-54

#### Vulnerabilities Identified:

##### LOW SEVERITY - Missing Config Validation
**Location:** `index.ts:15-17`
**Issue:** Constructor accepts config without validation.

```typescript
constructor(config: EmblemRemoteConfig) {
  this.config = config;
}
```

**Risk:**
- Empty apiKey could be passed
- Invalid baseUrl could be stored
- No sanitization of config values

**Recommendation:**
```typescript
constructor(config: EmblemRemoteConfig) {
  if (!config.apiKey || config.apiKey.trim() === '') {
    throw new Error('apiKey is required and cannot be empty');
  }
  if (config.baseUrl && !config.baseUrl.startsWith('https://')) {
    throw new Error('baseUrl must use https protocol');
  }
  this.config = config;
}
```

##### LOW SEVERITY - Promise Caching Without Error Handling
**Location:** `index.ts:20-23`
**Issue:** Failed promise is cached, preventing retry.

```typescript
private getInfo(): Promise<import("./types.js").VaultInfo> {
  if (!this._infoPromise) this._infoPromise = fetchVaultInfo(this.config);
  return this._infoPromise;
}
```

**Risk:**
- If first call fails (network error), subsequent calls will return same failed promise
- No way to retry after transient errors
- Poor user experience for recoverable failures

**Recommendation:**
```typescript
private getInfo(): Promise<VaultInfo> {
  if (!this._infoPromise) {
    this._infoPromise = fetchVaultInfo(this.config).catch(err => {
      this._infoPromise = undefined; // Clear cache on error
      throw err;
    });
  }
  return this._infoPromise;
}
```

##### POSITIVE FINDINGS:

1. ✅ **Lazy Loading**: Vault info fetched only when needed
2. ✅ **Caching**: Prevents redundant API calls
3. ✅ **Clean API**: Simple factory function pattern
4. ✅ **Type Exports**: Proper re-export of types

#### Security Score: 8/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 0
**Low Issues:** 2 (Missing validation, error caching)

---

### 6. Viem Adapter (src/viem.ts)

**Lines Reviewed:** 1-59

#### Vulnerabilities Identified:

##### MEDIUM SEVERITY - Unvalidated Message Conversion
**Location:** `viem.ts:15-28`
**Issue:** Complex message type coercion without validation could lead to unexpected serialization.

```typescript
} else {
  payload = String(message);
}
```

**Risk:**
- Objects converted to "[object Object]"
- Could sign unintended message content
- User might not realize what they're signing

**Recommendation:**
```typescript
} else {
  throw new Error(`Unsupported message type: ${typeof message}`);
}
```

##### LOW SEVERITY - No Signature Verification
**Location:** `viem.ts:30-35`
**Issue:** Signature returned from API is not verified against expected signer.

**Risk:**
- API could return signature from wrong address
- Man-in-the-middle could substitute signature
- No validation that returned signerAddress matches expected address

**Recommendation:**
```typescript
if (data.signerAddress.toLowerCase() !== evmAddress.toLowerCase()) {
  throw new Error(`Signature from unexpected address: ${data.signerAddress}`);
}
```

##### LOW SEVERITY - Missing TypedData Validation
**Location:** `viem.ts:38-46`
**Issue:** No validation of typed data structure before signing.

**Risk:**
- Malformed typed data could cause signing errors
- Missing required fields not caught early
- Domain separator could be manipulated

**Recommendation:**
- Validate domain, types, and message are non-null
- Validate domain has required fields (name, version, chainId)

##### POSITIVE FINDINGS:

1. ✅ **Multiple Format Support**: Handles various message formats (string, raw, Uint8Array, hex)
2. ✅ **Native viem Integration**: Uses official `toAccount` helper
3. ✅ **Transaction Normalization**: Proper use of normalizeTxForEmblem

#### Security Score: 7/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 1 (Unvalidated message conversion)
**Low Issues:** 2 (No signature verification, missing validation)

---

### 7. Ethers Adapter (src/ethers.ts)

**Lines Reviewed:** 1-195

#### Vulnerabilities Identified:

##### HIGH SEVERITY - Race Condition in Initialization
**Location:** `ethers.ts:35-37` and throughout
**Issue:** Multiple async calls can trigger concurrent initialization, causing race conditions.

```typescript
async getAddress(): Promise<string> {
  if (!this._address) await this.initialize();
  return this._address!;
}
```

**Risk:**
- Multiple concurrent calls to getAddress() trigger multiple fetchVaultInfo() calls
- Cached promise in client helps but not guaranteed if used standalone
- Could leak API key in race condition scenarios

**Recommendation:**
```typescript
private _initPromise?: Promise<void>;

async initialize(): Promise<void> {
  if (this._initPromise) return this._initPromise;
  this._initPromise = fetchVaultInfo(this._config).then(info => {
    this._address = info.evmAddress;
    this._vaultId = info.vaultId;
  });
  return this._initPromise;
}
```

##### MEDIUM SEVERITY - Missing From Address Validation
**Location:** `ethers.ts:97-101`
**Issue:** From address check only validates if present, doesn't ensure it's set.

```typescript
const from = (tx as any).from as string | undefined;
const addr = await this.getAddress();
if (from && from.toLowerCase() !== addr.toLowerCase()) {
  throw new Error("transaction from does not match signer address");
}
```

**Risk:**
- Transaction could be signed without from validation if not set
- populateTransaction sets from, but direct signTransaction calls might not

**Recommendation:**
```typescript
const from = (tx as any).from as string | undefined;
const addr = await this.getAddress();
if (!from) {
  (toSign as any).from = addr; // Set if missing
} else if (from.toLowerCase() !== addr.toLowerCase()) {
  throw new Error("transaction from does not match signer address");
}
```

##### MEDIUM SEVERITY - EIP712Domain Deletion Side Effect
**Location:** `ethers.ts:75-78`
**Issue:** Modifies types object by deleting EIP712Domain, could cause issues if object is reused.

```typescript
const cleanTypes = { ...types };
if (cleanTypes && (cleanTypes as any).EIP712Domain) {
  delete (cleanTypes as any).EIP712Domain;
}
```

**Risk:**
- Not actually a security issue since object is spread
- Good practice already followed

**Status:** Actually safe due to spread operator. Marked as informational.

##### LOW SEVERITY - ChainId Mutation Side Effect
**Location:** `ethers.ts:134` and `ethers.ts:137`
**Issue:** populateTransaction mutates wallet's _chainId as side effect.

```typescript
this._chainId = Number(network.chainId);
```

**Risk:**
- Unexpected state mutation during read operation
- Could cause issues in multi-chain scenarios
- Not thread-safe if used concurrently

**Recommendation:**
- Document this behavior
- Consider returning chainId instead of mutating state
- Or require explicit setChainId() call

##### LOW SEVERITY - Missing Null Check in Connect
**Location:** `ethers.ts:53-56`
**Issue:** Connect checks provider but error could be more specific.

```typescript
if (!provider) throw new Error("Provider cannot be null");
```

**Risk:** Minor - good validation present.

##### POSITIVE FINDINGS:

1. ✅ **Comprehensive Validation**: Validates `to` address and nonce presence
2. ✅ **Provider Integration**: Proper ethers provider integration
3. ✅ **Gas Estimation**: Fallback to 21000 if estimation fails
4. ✅ **Transaction Population**: Comprehensive populateTransaction implementation
5. ✅ **Private Fields**: Uses private fields for sensitive data (vaultId)

#### Security Score: 6/10

**Critical Issues:** 0
**High Issues:** 1 (Race condition in initialization)
**Medium Issues:** 1 (From address validation)
**Low Issues:** 2 (ChainId mutation, null check)

---

### 8. Web3 Adapter (src/web3.ts)

**Lines Reviewed:** 1-51

#### Vulnerabilities Identified:

##### LOW SEVERITY - No Input Validation
**Location:** Throughout `web3.ts`
**Issue:** Methods accept `any` types without validation.

```typescript
async signTypedData(domain: any, types: any, message: any): Promise<Hex> {
```

**Risk:**
- Null/undefined values could cause errors
- Invalid data passed directly to API
- No early error detection

**Recommendation:**
- Add basic null checks
- Validate required fields present
- Type parameters more strictly

##### LOW SEVERITY - No Config Validation
**Location:** `web3.ts:11-15`
**Issue:** Constructor accepts params without validation.

**Risk:**
- Empty vaultId could be passed
- Invalid address format
- No sanitization

**Recommendation:**
```typescript
constructor(address: `0x${string}`, vaultId: string, config: EmblemRemoteConfig) {
  if (!address || !address.startsWith('0x')) {
    throw new Error('Invalid address format');
  }
  if (!vaultId || vaultId.trim() === '') {
    throw new Error('vaultId cannot be empty');
  }
  this.address = address;
  this.#vaultId = vaultId;
  this.#config = config;
}
```

##### POSITIVE FINDINGS:

1. ✅ **Private Fields**: Uses # syntax for truly private vaultId and config
2. ✅ **Simple API**: Clean, focused interface
3. ✅ **Proper Return Types**: Returns correctly formatted response for web3.js

#### Security Score: 7/10

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 0
**Low Issues:** 2 (No validation)

---

### 9. Solana Module (src/solana.ts)

**Lines Reviewed:** 1-28

#### Vulnerabilities Identified:

##### INFORMATIONAL - Not Implemented
**Location:** `solana.ts:10-16`
**Issue:** Signing methods throw errors as not implemented.

**Status:** Expected behavior for unimplemented features.

**Recommendation:**
- Document in README that Solana signing is not yet supported
- Consider removing exports until implemented to prevent confusion

##### LOW SEVERITY - No Address Validation
**Location:** `solana.ts:6-8`
**Issue:** No validation that publicKey is valid base58 Solana address.

**Risk:**
- Invalid addresses could be stored
- Errors only occur when trying to use signer
- Poor user experience

**Recommendation:**
```typescript
constructor(publicKey: string) {
  if (!publicKey || typeof publicKey !== 'string') {
    throw new Error('Invalid Solana public key');
  }
  // Could add base58 format validation here
  this.publicKey = publicKey;
}
```

##### POSITIVE FINDINGS:

1. ✅ **Fail Fast**: Throws clear errors when methods are called
2. ✅ **Type Safety**: Properly typed
3. ✅ **Consistent API**: Matches pattern of other adapters

#### Security Score: 8/10 (high score due to minimal attack surface)

**Critical Issues:** 0
**High Issues:** 0
**Medium Issues:** 0
**Low Issues:** 1 (No validation)

---

## Summary of Findings by Severity

### High Severity Issues (Must Fix Before Production)

1. **Race Condition in Ethers Wallet Initialization** (`ethers.ts:35-37`)
   - Risk: Concurrent initialization could cause multiple API calls
   - Impact: Potential state corruption and excessive API usage
   - Priority: **HIGH - Fix Before Release**

### Medium Severity Issues (Should Fix Soon)

1. **Information Disclosure in Error Messages** (`http.ts:21, 40`)
   - Impact: May leak sensitive server information

2. **Unsafe Error Handling in Vault Module** (`vault.ts:12-17`)
   - Impact: Masks authentication and network errors

3. **Integer Overflow in Utils** (`utils.ts:23-24`)
   - Impact: Loss of precision for large nonce values

4. **Unvalidated Message Conversion in Viem** (`viem.ts:15-28`)
   - Impact: Could sign unintended message content

5. **Missing From Address Validation in Ethers** (`ethers.ts:97-101`)
   - Impact: Transactions might be signed without proper validation

### Low Severity Issues (Improve When Possible)

Multiple input validation, error handling, and code quality issues across all modules. See individual module sections for details.

---

## Recommendations

### Immediate Actions Required

#### 1. Fix Race Condition in Ethers Wallet

**Priority:** HIGH

Add promise caching to `initialize()` method:

```typescript
export class EmblemEthersWallet extends AbstractSigner {
  private readonly _config: EmblemRemoteConfig;
  private _address: `0x${string}` | null = null;
  private _vaultId: string | null = null;
  private _chainId = 1;
  private _initPromise?: Promise<void>;

  async initialize(): Promise<void> {
    if (this._initPromise) return this._initPromise;

    this._initPromise = fetchVaultInfo(this._config).then(info => {
      this._address = info.evmAddress;
      this._vaultId = info.vaultId;
    }).catch(err => {
      // Clear promise on error to allow retry
      this._initPromise = undefined;
      throw err;
    });

    return this._initPromise;
  }

  // Update all methods to use new initialize()
  async getAddress(): Promise<string> {
    if (!this._address) await this.initialize();
    return this._address!;
  }
}
```

### Short-Term Improvements (Next Release)

#### 2. Add Request Timeouts

Add timeout support to all HTTP requests:

```typescript
export async function emblemPost<T = any>(
  path: string,
  body: any,
  { apiKey, baseUrl = "https://api.emblemvault.ai", timeout = 30000 }: EmblemRemoteConfig & { timeout?: number }
): Promise<T> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const res = await fetch(buildSecureUrl(baseUrl, path), {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "x-api-key": apiKey,
      },
      body: JSON.stringify(body, (key: string, value: any) =>
        typeof value === "bigint" ? value.toString() : value
      ),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`Emblem signer error ${res.status}: ${text || res.statusText}`);
    }

    return res.json() as Promise<T>;
  } catch (err) {
    clearTimeout(timeoutId);
    throw err;
  }
}
```

#### 3. Add Input Validation Layer

Create validation utilities:

```typescript
// src/validation.ts
export function validateApiKey(apiKey: string): void {
  if (!apiKey || typeof apiKey !== 'string') {
    throw new Error('apiKey is required');
  }
  if (apiKey.trim() === '') {
    throw new Error('apiKey cannot be empty or whitespace');
  }
}

export function validateBaseUrl(baseUrl?: string): void {
  if (!baseUrl) return; // undefined is ok, will use default

  if (!baseUrl.startsWith('https://')) {
    throw new Error('baseUrl must use HTTPS protocol');
  }

  if (baseUrl.includes('@')) {
    throw new Error('baseUrl cannot contain @ symbol');
  }
}

export function validateEthereumAddress(address: string): void {
  if (!address || typeof address !== 'string') {
    throw new Error('Address is required');
  }
  if (!address.startsWith('0x')) {
    throw new Error('Address must start with 0x');
  }
  if (!/^0x[0-9a-fA-F]{40}$/.test(address)) {
    throw new Error('Invalid Ethereum address format');
  }
}

export function validateVaultId(vaultId: string): void {
  if (!vaultId || typeof vaultId !== 'string') {
    throw new Error('vaultId is required');
  }
  if (vaultId.trim() === '') {
    throw new Error('vaultId cannot be empty');
  }
}

export function validateSafeInteger(value: any, fieldName: string): number {
  const num = Number(value);
  if (!Number.isSafeInteger(num)) {
    throw new Error(`${fieldName} value too large for safe integer conversion`);
  }
  return num;
}
```

Apply these validators in constructors and critical methods.

#### 4. Improve Error Handling

Refine error handling in `vault.ts`:

```typescript
export async function fetchVaultInfo(config: EmblemRemoteConfig): Promise<VaultInfo> {
  let data: {
    vaultId: string;
    address: string;
    evmAddress: `0x${string}`;
    created_by?: string;
  };

  try {
    data = await emblemGet("/vault/info", config);
  } catch (err: any) {
    // Only fallback for 405 Method Not Allowed
    if (err.message?.includes('405') || err.message?.includes('Method Not Allowed')) {
      console.warn('GET /vault/info not supported, falling back to POST');
      data = await emblemPost("/vault/info", {}, config);
    } else {
      // Re-throw all other errors (auth failures, network issues, etc.)
      throw err;
    }
  }

  // Validate response data
  if (!data.vaultId || !data.address || !data.evmAddress) {
    throw new Error('Invalid vault info response: missing required fields');
  }

  if (!data.evmAddress.startsWith('0x')) {
    throw new Error('Invalid evmAddress format in response');
  }

  return {
    vaultId: data.vaultId,
    tokenId: data.vaultId,
    address: data.address,
    evmAddress: data.evmAddress,
    created_by: data.created_by,
  };
}
```

### Long-Term Enhancements

#### 5. Add Signature Verification

Verify signatures returned from API match expected signer:

```typescript
// In viem.ts signMessage
const data = await emblemPost<{
  signerAddress: string;
  signature: Hex;
}>("/sign-eth-message", { vaultId, message: payload }, config);

// Verify signer address matches
if (data.signerAddress.toLowerCase() !== evmAddress.toLowerCase()) {
  throw new Error(
    `Signature from unexpected address. Expected: ${evmAddress}, Got: ${data.signerAddress}`
  );
}

return data.signature;
```

Apply similar verification to all signing methods.

#### 6. Add Comprehensive Logging

Consider adding optional debug logging:

```typescript
export interface EmblemRemoteConfig {
  apiKey: string;
  baseUrl?: string;
  debug?: boolean;
  logger?: (message: string, data?: any) => void;
}

function log(config: EmblemRemoteConfig, message: string, data?: any) {
  if (config.debug && config.logger) {
    config.logger(message, data);
  }
}
```

#### 7. Sanitize Error Messages

Create error sanitization utility:

```typescript
function sanitizeErrorMessage(status: number, text: string): string {
  // Don't expose server error details
  if (status >= 500) {
    return 'Internal server error occurred';
  }

  // Sanitize 4xx errors to avoid leaking API structure
  if (status === 401 || status === 403) {
    return 'Authentication failed';
  }

  if (status === 404) {
    return 'Resource not found';
  }

  // For other errors, limit exposed information
  return `Request failed with status ${status}`;
}
```

#### 8. Add Rate Limiting Protection

Consider client-side rate limiting:

```typescript
class RateLimiter {
  private requests: number[] = [];
  private readonly maxRequests: number;
  private readonly timeWindow: number;

  constructor(maxRequests: number = 10, timeWindowMs: number = 1000) {
    this.maxRequests = maxRequests;
    this.timeWindow = timeWindowMs;
  }

  async throttle(): Promise<void> {
    const now = Date.now();
    this.requests = this.requests.filter(time => now - time < this.timeWindow);

    if (this.requests.length >= this.maxRequests) {
      const oldestRequest = this.requests[0];
      const waitTime = this.timeWindow - (now - oldestRequest);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      return this.throttle();
    }

    this.requests.push(now);
  }
}
```

---

## Testing Recommendations

### Security Testing Checklist

- [ ] Test concurrent initialization in ethers wallet
- [ ] Test with empty/null/undefined inputs for all public methods
- [ ] Test error scenarios and verify errors don't leak sensitive info
- [ ] Test with extremely large bigint values (> Number.MAX_SAFE_INTEGER)
- [ ] Test signature verification with mismatched addresses
- [ ] Test timeout behavior with slow/unresponsive servers
- [ ] Test rate limiting behavior under load
- [ ] Fuzz test message signing with various input types
- [ ] Test multi-chain scenarios for state consistency

### Penetration Testing Focus Areas

1. **API Key Handling**: Verify keys never logged or exposed in errors
2. **Message Signing**: Test with malicious/malformed messages
3. **Transaction Signing**: Test with manipulated transaction fields
4. **Error Handling**: Verify no sensitive data in error responses
5. **Client-Side Trust Model**: Document that dApps have full control over API keys and requests

---

## Dependencies Security

### Current Status

The package has minimal dependencies:
- TypeScript (dev)
- Vitest (dev)
- ethers (peer)
- viem (peer)
- dotenv (dev)

### Recommendations

1. Run `npm audit` regularly
2. Keep peer dependencies up to date
3. Consider using dependency scanning tools (Snyk, Dependabot)
4. Pin exact versions for production deployments

---

## Deployment Guidelines

### Before Deploying to Production

1. ✅ Fix all HIGH severity issues
2. ✅ Fix all MEDIUM severity issues
3. ✅ Add comprehensive input validation
4. ✅ Add request timeouts
5. ✅ Implement signature verification
6. ✅ Add security-focused integration tests
7. ✅ Conduct penetration testing
8. ✅ Set up monitoring for API errors
9. ✅ Document security considerations in README
10. ✅ Implement rate limiting if applicable

### Runtime Security Checklist

- [ ] API keys stored in environment variables, never in code
- [ ] HTTPS enforced for all API communication
- [ ] Regular security updates for dependencies
- [ ] Error monitoring and alerting configured
- [ ] API rate limits understood and respected
- [ ] Backup/recovery procedures documented

---

## Client-Side Security Model

This library is designed for use in environments where users provide their own API keys. Important security considerations:

### Trust Model
- **Client-side usage**: Users must trust the dApp code they run
- **API key exposure**: API keys are necessarily exposed to the JavaScript runtime
- **No technical enforcement**: Client-side code can always be modified via browser dev tools, breakpoints, or code injection
- **baseUrl flexibility**: Required for dev/staging/prod environments

### Why URL Validation Is Not a Security Control

In client-side contexts:
- Attacker with code access can intercept `fetch()` calls directly
- Browser dev tools can modify any variable, even "private" ones
- XSS or supply chain attacks bypass any library-level protections
- If attacker controls the code, they already have the API key

**Conclusion:** URL validation provides error handling, not security. The security boundary is "do you trust the dApp code?"

### Security Recommendations for Users

1. **Only use trusted dApps** - Verify source code when possible
2. **Separate API keys** - Use different keys for different dApps
3. **Monitor usage** - Watch for unexpected signing requests
4. **Staging environments** - Test with staging API keys first

### Security Recommendations for Implementers

1. **Document trust model** - Make clear that users trust your dApp code
2. **Open source when possible** - Allow security audits
3. **Minimize dependencies** - Reduce supply chain risk
4. **Use CSP headers** - Protect against XSS where possible

---

## Conclusion

The emblem-vault-ai-signers package has a solid foundation with good TypeScript practices and clear separation of concerns. The identified security issues are fixable and mostly relate to race conditions, input validation, and error handling.

**Priority Actions:**
1. Fix race condition in ethers wallet (HIGH)
2. Add comprehensive input validation (MEDIUM)
3. Implement request timeouts (MEDIUM)
4. Add signature verification (MEDIUM)
5. Improve error handling (MEDIUM)
6. Document client-side security model in README

With these fixes applied, the security score would improve from **7.5/10** to approximately **8.5/10**, making it suitable for production use with proper operational security practices.

---

**Audit Completed:** 2025-11-10
**Next Recommended Audit:** After implementing high/medium severity fixes, or in 6 months

